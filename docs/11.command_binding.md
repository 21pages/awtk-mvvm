## 第 11 章 命令绑定

在传统的开发方式中，用户点击视图中控件的时候，控件会触发一些事件，在这些事件处理函数中，去完成某些任务。在 MVVM 模式当中，则是通过命令绑定规则，建立控件事件与模型函数之间的关系，用户触发某个事件之后，框架自动执行模型的对应的函数。这种绑定关系更容易理解，让视图与模型之间的耦合也更加松散。

### 11.1 命令绑定的基本用法

命令绑定规则也是一个控件属性：

属性的名称由两部分组成，两者之间用英文冒号分隔。

* v-on 表示该属性是一个命令绑定规则。
* 第二部分是控件事件的名称，表示对该事件触发时，自动执行指定的命令。

命令的名称放在'{'和'}'之间，里面是视图模型中命令的名称。

如：

```
v-on:click="{apply}" 表示将控件的"click"事件与视图模型的"apply"命令关联起来。
```

目前支持的事件有(以后更加需要增加):

* click 点击事件
* pointer_down 指针按下事件
* pointer_up 指针松开事件
* key_down 按键按下事件
* key_up 按键松开事件
* value_changed 值改变事件


我们还是以温度控制器为例，假设我们调解温度之后，点击"Apply"按钮才让新的温度生效，如果新的温度与旧的温度相同，则禁用"Apply"按钮，否则启用"Apply"按钮。

新的界面大概是这样的：

![view](images/command_temperature_view.png)

它的界面描述文件是这样：

```
<window v-model="temperature">
  <label  x="center" y="middle:-40" w="80%" h="40" v-data:text="{value}"/>
  <slider x="center" y="middle" w="90%" h="20" v-data:value="{value}"/>
  <button text="Apply" x="center" y="middle:40" w="40%" h="40" v-on:click="{apply}"/>
</window>
```

拖动滑块改变温度的值，如果新的值于旧的值不同，"Apply"按钮处于启用状态，当点击"Apply"时，就会调用视图模型中的"apply"，它将旧的值设置为新的值，"Apply"按钮重新处于禁用状态。

在前面介绍用 C 语言实现视图模型时，已经看过视图模型里关于命令处理的代码，这里我们再回顾一下：

```
static bool_t temperature_can_exec_apply(temperature_t* temperature, const char* args) {
  return temperature->old_value != temperature->value;
}

static ret_t temperature_apply(temperature_t* temperature, const char* args) {
  temperature->old_value = temperature->value;
  return RET_OBJECT_CHANGED;
}

static bool_t temperature_view_model_can_exec(object_t* obj, const char* name, const char* args) {
  temperature_view_model_t* vm = (temperature_view_model_t*)(obj);
  temperature_t* temperature = vm->temperature;

  if (tk_str_eq("apply", name)) {
    return temperature_can_exec_apply(temperature, args);
  } else {
    return FALSE;
  }
}

static ret_t temperature_view_model_exec(object_t* obj, const char* name, const char* args) {
  temperature_view_model_t* vm = (temperature_view_model_t*)(obj);
  temperature_t* temperature = vm->temperature;

  if (tk_str_eq("apply", name)) {
    return temperature_apply(temperature, args);
  } else {
    log_debug("not found %s\n", name);
    return RET_NOT_FOUND;
  }
}

```

在命令绑定规则中，还可以指定一些高级参数，这些参数之间用英文逗号分隔，后面我们将详细介绍这些参数的作用。

Windows 的命令行下，读者可以运行 demo6 来查看实际的效果。

```
bin\demo6.exe
```

### 11.2 命令的参数

在命令绑定规则中，可以指定一个参数，该参数并不是必须的，但有时命令参数确实能带来不少便利。

在命令绑定规则中，通过 Args 指定命令的参数。如：

```
v-on:click="{add_char, Args=0}"
```

现在我们以一个简单计算器的例子，来看看命令参数是如何使用，以及它带来的便利性。

计算器的界面大概是这样的：

![view](images/calculator_view.png)

计算器的界面描述文件是这样的：

```
<window v-model="calculator">
  <edit x="c" y="10" w="90%" h="30" focus="true" input_type="custom" text="" tips="expression" v-data:text="{expr}"/>
  <view y="60" x="c" w="90%" h="-60" is_keyboard="true" 
    children_layout="default(r=4,c=4,m=5,s=5)" >
    <button name="key" text="0" v-on:click="{add_char, Args=0}"/>
    <button name="key" text="1" v-on:click="{add_char, Args=1}"/>
    <button name="key" text="2" v-on:click="{add_char, Args=2}"/>
    <button name="key" text="3" v-on:click="{add_char, Args=3}"/>
    <button name="key" text="4" v-on:click="{add_char, Args=4}"/>
    <button name="key" text="5" v-on:click="{add_char, Args=5}"/>
    <button name="key" text="6" v-on:click="{add_char, Args=6}"/>
    <button name="key" text="7" v-on:click="{add_char, Args=7}"/>
    <button name="key" text="8" v-on:click="{add_char, Args=8}"/>
    <button name="key" text="9" v-on:click="{add_char, Args=9}"/>
    <button name="key" text="+" v-on:click="{add_char, Args=+}"/>
    <button name="key" text="-" v-on:click="{add_char, Args=-}"/>
    <button name="key" text="*" v-on:click="{add_char, Args=*}"/>
    <button name="key" text="/" v-on:click="{add_char, Args=/}"/>
    <button name="key" text="=" v-on:click="{eval}"/>
    <button name="backspace" text="<=" v-on:click="{remove_char}"/>
  </view>
</window>

```

这里我们可以看到，数字和运算符全部绑定到"add_char"这个命令上，只是通过参数来区分的，视图模型中，我们只需要实现 add_char 函数即可。如果不使用命令参数，我们就要为每一个按钮写一个命令，那是非常繁琐的。

这个函数的实现也是相当的简单，把参数作为字符串追加到表达式中即可：

```
static ret_t calculator_add_char(calculator_t* calculator, const char* args) {
  str_append(&(calculator->expr), args);
  return RET_OBJECT_CHANGED;
}
```

读者可以从 demos/common/calculator.c 文件中看到完整的代码。这个例子有点特殊，它的全部代码都是从calculator.json自动产生出来的。

```
{
  "name":"calculator",
  "desc":"a simple calculator",
  "includes":["tkc/expr_eval.h"],
  "props": [
    {
      "name":"expr",
      "desc":"the expression",
      "type":"char*"
    }
  ],
  "cmds": [
    {
      "name":"add_char",
      "canExec": true,
      "impl":"str_append(&(calculator->expr), args);",
      "desc":"add a char to expression"
    },
    {
      "name":"remove_char",
      "canExec": "return calculator->expr.size > 0;",
      "impl":"str_pop(&(calculator->expr));",
      "desc":"remove last char of expression"
    },
    {
      "name":"eval",
      "impl":"str_from_float(&(calculator->expr), tk_expr_eval(calculator->expr.str));",
      "canExec": "return calculator->expr.size > 0;",
      "desc":"eval the expression"
    }
  ]
}

```

写这个JSON是在定义模型的接口，这也是一个设计的过程，能帮助开发者思考，同时又能少些大量单调的代码，花些时间去掌握代码产生器是值得的。


### 11.3 更新模型的参数
### 11.4 关闭当前的参数
### 11.5 关闭当前的参数
### 11.6 关闭当前的参数